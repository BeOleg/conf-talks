# Auth with GraphQL

Сперва разберемся с самым каверзным вопросом, который звучит на собеседованиях — что такое Аутентификация, Идентификация и Авторизация.

**Аутентификация** — процедура проверки подлинности пользователя путём сравнения введённого им логина и пароля.

**Идентификация** — процедура распознания пользователя по токену или кукам.

**Авторизация** — процедура проверки прав доступа к ресурсам на выполнение определённых действий.

Как обычно происходит дело на практике:

- пользователь вводит логин и пароль
- сервер производит аутентификацию и если все окей, то возвращает либо токен, либо индетификатор сессии через куки
- при выполнении какого-либо действия над данными, сервер должен:
  - произвести индетификацию пользователя по токену, либо сессии
  - произвести авторизацию по таблице ACL (или еще как-то) — проверить права доступа для индетифицированного пользователя
  - если авторизация пройдена, то перейти к операции над данными

## Sign In (Аутентификация)

Sign In (ввод логина и пароля) может производиться двумя спосабами. Первый старый добрый ендпоинт, который принимает POST-перменные и возвращает токен. Второй создать в GraphQL-схеме query или mutation который принимает логин и пароль через аргументы, и в ответе возвращает токен и возможно набор каких-то данных.

Какой подход выбрать, ендпоинт или GraphQL? Это зависит от того,

- хотите ли вы возвращать помимо токена сразу какие-либо данные (тогда лучше вход сделать через GraphQL)
- хотите ли вы защитить GraphQL от "левых обращений" без токенов (тогда делать через обычный ендпоинт)

Обычно у многих уже реализована аутентификация, поэтому нет ничего зазорного использовать обычный REST для этого. Один запрос отправляется для получения токена, второй запрос отправляется для получения данных для клиентского приложения через GraphQL. Но если хотите сразу авторизоваться и получить вагон данных, то юзайте сразу GraphQL. Т.к. GraphQL статически типизирован и описание всех ваших данных возвращаемых с сервера, сильно поможет в будущем при рефакторинге системы.

## JWT, cookie (Идентификация)

В мире GraphQL для генерации токенов сильно прижился [JWT](https://jwt.io/). JSON Web Token (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных авторизации в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения своей личности. В [википедии](https://ru.wikipedia.org/wiki/JSON_Web_Token) достаточно коротко и хорошо расписано про JWT.

Чем JWT полюбился народу, это тем что на стороне сервера не надо заводить сессионное хранилище. Если от клиента прилетел JWT-токен, то любая нода в вашем кластере может провалидировать его по секретному ключу.

Где хранить JWT токен на клиенте, в DOM-хранилище или куках? Лучше в куках с флагом httpOnly, т.к. тогда у злоумышленника нет возможности считать токен через JavaScript (XSS). Любой браузерный экстеншн имеет доступ к вашему локальному хранилищу и коду, будьте осторожны.

А вот для мобильных приложений токены удобнее всего передавать через дополнительные HTTP-заголовки. Там уже не так просто злоумышленнику считать переменные из приложения. Но вот работа с куками это уже отдельный ад.

Поэтому хорошим тоном будет, если ваш сервер поддерживает передачу токенов через cookie (для браузеров) и через http-заголовки (для мобильных приложений). Пусть сам клиент решает как ему безопаснее и удобнее всего передавать вам токены.

## Прикручиваем ACL (Авторизация)

А вот теперь самый важный и интересный момент по поводу авторизации. Ее можно и нужно настраивать на следующих трех уровнях:

- на уровне сервера (express, koa и пр.)
- на уровне GraphQL-схемы (глобально на первых полях схемы)
- на уровне связей между типами (в resolve методах)

Давайте поподробнее разберем эту тему.

### 1. Авторизация на уровне сервера (express, koa и пр.)

TODO:

### 2. Авторизация на уровне GraphQL-схемы (глобально на первых полях схемы)

TODO:

### 3. Авторизация на уровне связей между типами (в resolve методах)

TODO:

## Почему я использую три токена (user, account, admin)

В большинстве случаев разработчики пользуется всего одним токеном при работе с сервером. Долгим и мучительным рефакторингом я для себя вынес одно великое правило, что надо использовать 3 токена:

- `user` — чтобы индетифицировать текущего пользователя, который ввел логин и пароль. Никакие данные я обычно с id-шником пользователя не храню; для этого использую понятие аккаунт.
- `account` — чтобы индетифицировать доступ к каким-то данным. Например: какой-то менеджер регистрирует личный кабинет, через полгода увольняется; на его место приходит новый менеджер, и теперь везде надо перебивать старое мыло пользователя на новое. Чтоб избежать этого бардака, я для себя вынес правило, что юзеры это ненадежный материал, [bus factor](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BA%D1%82%D0%BE%D1%80_%D0%B0%D0%B2%D1%82%D0%BE%D0%B1%D1%83%D1%81%D0%B0) никто не отменял. Поэтому все данные храню в каком-то аккаунте, а вот пользователя (`user`) уже прикрепляю к какому-то аккаунту (`account`). Еще часто бывает так, что к одному аккаунту (набору данных) хотят иметь доступ разные пользователи и подход с `user` и `account` как раз ложиться в этот сценарий.
- `admin` — чтобы индетифицировать админа системы. Во-первых хреново путать админа и юзера в один токен, кто-нибудь из прогеров накосячит и все пользователи начнут иметь доступ ко всему (станут админами). Во-вторых частенько требуется, чтобы админ мог зайти в аккаунт пользователя и посмотреть его глазами что у него происходит в личном кабинете (для этого к запросу админа надо просто присандалить токен юзера и аккаунта). Т.е. админ должен легко получать через админку токены `user` и `account` и уже в стандартном публичном интерфейсе ковыряться как пользователь. А в закрытую админскую часть ходить только под токеном `admin`.

Вот три таких нехитрых токена позволяют хорошо запроектировать доступ данным в вашем приложении. Пользуйтесь на здоровье.
