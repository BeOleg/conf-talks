# Загрузка файлов в GraphQL

-----

### GraphQL точился <br/>под передачу типизированных <br/>и связанных между собой данных <br/>в формате JSON.

-----

### В спецификации и пакете `graphql` нет ни слова про загрузку файлов.

-----

## Но выход всегда есть!

-----

## На данный момент есть 3 способа загрузки файлов:

- поле с Base64
- грузить через REST, а в GraphQL передавать только ссылки
- [graphql-multipart-request-spec]()

-----

## 1. Поле с Base64

На клиенте вы берете файл, энкодите его в base64 и передаете как обычную строку на сервер.

На сервере проделываете похожие операции, только в обратном порядке.

-----

### Минусы такого подхода:

- как минимум +30% в размере передаваемых данных по сети
- кушаем процессор как на клиенте так и на сервере
- тратим много дорогой памяти

-----

## 2. Грузить через REST, а в GraphQL передавать только ссылки на загруженные файлы

-----

Вы грузите свой файл в специальное хранилище через старый добрый REST, получаете ссылку на загруженный файл.

И уже эту ссылку загруженного файла передаете в вашем GraphQL-запросе.

-----

### Плюсы такого подхода:

- есть уже куча инструментов и библиотек
  - догрузка файлов
  - отображение процесса загрузки
- разделение серверов по ролям (легче админить)
  - файловые-сервера
  - graphql-сервера

-----

## Да, кстати. А как будите отдавать файлы обратно клиентам?

К бабке не ходи, в 99% по ссылке, а не в теле GraphQL-ответа.

Поэтому и загружать через GraphQL смысла не вижу.

-----

### Вот как бы вы решили задачу загрузки картинки и нарезки тумбнеилов?

-----

#### Можно через Amazon S3 + lambda-функций

- на вашем сервере генерируете ссылку для аплоада картинки `signedUrl`
- клиент по ней загружает файл
- в Amazon S3 срабатывает `hook` на появление нового файла, который вызовет `lambda`-функцию нарезки картинок
- а потом отправляете в GraphQL ссылки на уже загруженные и нарезанные картинки

Детальнее можно [почитать тут](https://github.com/nodkz/conf-talks/tree/master/articles/graphql/fileUploads/README.md)

-----

## 3. graphql-multipart-request-spec

Ну это когда, прям очень сильно надо передавать файлы вместе с GraphQL-запросом.

Ссылка на [спецификацию](https://github.com/jaydenseric/graphql-multipart-request-spec) от Jayden Seric

-----

### Тогда вам нужно:

- чутка докрутить ваш GraphQL-сервер
- научить клиента правильно паковать GraphQL-запрос и файлы в `multipart/form-data`

-----

### Чем реализация этой спеки хороша в NodeJS:

- вложенность файла на любую глубину (правда только через `variables`)
- отмена загрузки файлов
- получение файла в виде `Stream` в вашем `resolve-методе`

Берите [graphql-upload](https://github.com/jaydenseric/graphql-upload)

-----

### Принцип работы

![Диаграмма экосистемы](./diagram-ecosystem-server.svg) <!-- .element: style="width: 90vw;" class="plain"  -->

На уровне сервера парситься `body`, выдергивается файл в виде стрима и подменяется в `variables`, которые передаются в `graphql`

-----

### Пример отправки запроса:

```bash
curl localhost:3000/graphql \
  -F operations='{
    "query": "mutation ($poster: Upload) {
       createPost(id: 5, poster: $poster) { id }
    }",
    "variables": { "poster": null }
   }' \
  -F map='{ "0": ["variables.poster"] }' \
  -F 0=@poster.jpg

```

<span class="fragment" data-code-focus="3, 6" />
<span class="fragment" data-code-focus="6,8" />
<span class="fragment" data-code-focus="8,9" />

-----

## В сухом остатке

Старайтесь не грузить свои GraphQL сервера загрузкой файлов. Оставьте это дело старому доброму REST.

-----

Подробнее про загрузку файлов в GraphQL можно [почитать тут](https://github.com/nodkz/conf-talks/tree/master/articles/graphql/fileUploads/README.md)